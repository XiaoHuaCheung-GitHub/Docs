<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Anson Cheung">
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>Command: FIND - Anson Tech Notes</title>
  <link href='css/google-font.css' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="css/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Command: FIND";
    var mkdocs_page_input_path = "Linux/P1-Commands/command-find.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> Anson Tech Notes</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Language</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../Language/">开发语言学习笔记和参考</a>
                </li>
                <li class="">
                    
    <span class="caption-text">C# Lang</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../Language/C%23-Lang/">C# 学习笔记和参考</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">C Lang</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../Language/C-Lang/">C 学习笔记和参考</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Java Lang</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../Language/Java-Lang/">Java 学习笔记和参考</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Linux</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../">Linux 学习笔记和参考</a>
                </li>
                <li class=" current">
                    
    <span class="caption-text">P1 Commands</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../">Linux命令参考</a>
                </li>
                <li class="toctree-l3 current">
                    
    <a class="current" href="./">Command: FIND</a>
    <ul class="subnav">
            
    <li class="toctree-l4"><a href="#command-find">Command: FIND</a></li>
    
        <ul>
        
            <li><a class="toctree-l5" href="#description">Description</a></li>
        
            <li><a class="toctree-l5" href="#syntax">Syntax</a></li>
        
            <li><a class="toctree-l5" href="#options">Options</a></li>
        
            <li><a class="toctree-l5" href="#expressions">Expressions</a></li>
        
            <li><a class="toctree-l5" href="#expression-options">Expression Options</a></li>
        
            <li><a class="toctree-l5" href="#tests">Tests</a></li>
        
            <li><a class="toctree-l5" href="#actions">Actions</a></li>
        
            <li><a class="toctree-l5" href="#handling-unusual-file-names">Handling Unusual File Names</a></li>
        
            <li><a class="toctree-l5" href="#operators">Operators</a></li>
        
            <li><a class="toctree-l5" href="#environment-variables">Environment Variables</a></li>
        
            <li><a class="toctree-l5" href="#syntax_1">Syntax</a></li>
        
            <li><a class="toctree-l5" href="#suppressing-error-messages-when-using-find">Suppressing Error Messages When Using find</a></li>
        
            <li><a class="toctree-l5" href="#suppressing-error-messages-when-using-find_1">Suppressing Error Messages When Using find</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../command-runuser/">Command: RUNUSER</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../command-su/">Command: SU</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../command-sudo/">Command: SUDO</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">P2 Shell</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../P2-Shell/">Linux Shell 脚本</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">P3 Topic</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../P3-Topic/">Index</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">P4 Activity</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../P4-Activity/">Index</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Git</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../git/">Git 使用参考</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../git/command-git/">Command: GIT</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Gradle</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../gradle/">Index</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../gradle/1-java-app/">构建Java 应用程序</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../gradle/2-java-web/">构建Java Web应用程序</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../gradle/3-java-ear/">构建J2EE应用程序</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">Anson Tech Notes</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
        
          <li>P1 Commands &raquo;</li>
        
      
        
          <li>Linux &raquo;</li>
        
      
    
    <li>Command: FIND</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="command-find">Command: FIND</h1>
<h2 id="description">Description</h2>
<p>find locates files on your system. Within each directory tree specified by the given paths, it evaluates the given expression from left to right, according to the rules of precedence (see "Operators", below) until the outcome is known. The outcome is "known" when the left hand side of the expression is determined to be FALSE for AND operations, or TRUE for OR operations. At that point find moves on to the next path until all paths have been searched.</p>
<p>find is a fundamental and extremely powerful tool for working with the files on your linux system. It can be used on its own to locate files, or in conjunction with other programs to perform operations on those files.</p>
<h2 id="syntax">Syntax</h2>
<p>find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</p>
<h2 id="options">Options</h2>
<p>The -H, -L and -P options control the treatment of symbolic links. Arguments following these are taken to be names of files or directories to be examined, up to the first argument that begins with "-", or the argument "(" or "!". That argument and any following arguments are taken to be the expression describing what is being searched. If no paths are given, the current directory is used. If no expression is given, the expression -print is used (but you should probably consider using -print0 instead, anyway. More information on this below).</p>
<p>The arguments in the expression list are also referred to as "options," but the five "real" options -H, -L, -P, -D and -O must appear before the first path name, if they are used at all. A double-dash ("--") can also be used to signal that any remaining arguments are not options (though ensuring that all start points begin with either "./" or "/" is generally safer if you use wildcards in the list of start points).</p>
<p>-P  Never follow symbolic links. This is the default. When find examines or prints information a file, and the file is a symbolic link, the information used will be taken from the properties of the symbolic link itself.
-L  Follow symbolic links. When find examines or prints information about files, the information used will be taken from the properties of the file to which the link points, not from the link itself (unless it is a broken symbolic link or find is unable to examine the file to which the link points). Use of this option implies -noleaf. If you later use the -P option, -noleaf will still be in effect. If -L is in effect and find discovers a symbolic link to a subdirectory during its search, the subdirectory pointed to by the symbolic link will be searched.</p>
<p>When the -L option is in effect, the -type predicate will always match against the type of the file that a symbolic link points to rather than the link itself (unless the symbolic link is broken). Using -L causes the -lname and -ilname predicates always to return false.
-H  Do not follow symbolic links, except while processing the command line arguments. When find examines or prints information about files, the information used will be taken from the properties of the symbolic link itself. The only exception to this behaviour is when a file specified on the command line is a symbolic link, and the link can be resolved. For that situation, the information used is taken from whatever the link points to (that is, the link is followed). The information about the link itself is used as a fallback if the file pointed to by the symbolic link cannot be examined. If -H is in effect and one of the paths specified on the command line is a symbolic link to a directory, the contents of that directory will be examined (though specifying -maxdepth 0 would prevent this).
If more than one of -H, -L and -P is specified, each overrides the others; the last one appearing on the command line takes effect. Since it is the default, the -P option should be considered to be in effect unless either -H or -L is specified. GNU find frequently stats files during the processing of the command line itself, before any searching has begun. These options also affect how those arguments are processed. Specifically, there are a number of tests that compare files listed on the command line against a file we are currently considering. In each case, the file specified on the command line will have been examined and some of its properties will have been saved. If the named file is in fact a symbolic link, and the -P option is in effect (or if neither -H nor -L were specified), the information used for the comparison will be taken from the properties of the symbolic link. Otherwise, it will be taken from the properties of the file the link points to. If find cannot follow the link (for example because it has insufficient privileges or the link points to a nonexistent file) the properties of the link itself will be used.</p>
<p>When the -H or -L options are in effect, any symbolic links listed as the argument of -newer will be dereferenced, and the timestamp will be taken from the file to which the symbolic link points. The same consideration applies to -newerXY, -anewer and -cnewer.</p>
<p>The -follow option has a similar effect to -L, though it takes effect at the point where it appears (that is, if -L is not used but -follow is, any symbolic links appearing after -follow on the command line will be dereferenced, and those before it will not).</p>
<p>-D debugoptions 
Print diagnostic information; this can be helpful to diagnose problems with why find is not doing what you want. The list of debug options should be comma separated. Compatibility of the debug options is not guaranteed between releases of findutils. For a complete list of valid debug options, see the output of find -D help. Valid debug options include:</p>
<p>help    Explain the debugging options.
tree    Show the expression tree in its original and optimised form.
stat    Print messages as files are examined with the stat and lstat system calls. The find program tries to minimize such calls.
opt Prints diagnostic information relating to the optimisation of the expression tree; see the -O option.
rates   Prints a summary indicating how often each predicate succeeded or failed.
-Olevel 
Enables query optimisation. The find program reorders tests to speed up execution while preserving the overall effect; that is, predicates with side effects are not reordered relative to each other. The optimisations performed at each optimisation level are as follows.</p>
<p>There must not be a space in between -O and the decimal representing the optimization level. The decimals and their meanings are as follows:</p>
<p>0   Equivalent to optimisation level 1.
1   This is the default optimisation level and corresponds to the traditional behaviour. Expressions are reordered so that tests based only on the names of files (for example -name and -regex) are performed first.
2   Any -type or -xtype tests are performed after any tests based only on the names of files, but before any tests that require information from the inode. On many modern versions of Unix, file types are returned by readdir() and so these predicates are faster to evaluate than predicates which need to stat the file first.
3   At this optimisation level, the full cost-based query optimiser is enabled. The order of tests is modified so that cheap (i.e. fast) tests are performed first and more expensive ones are performed later, if necessary. Within each cost band, predicates are evaluated earlier or later according to whether they are likely to succeed or not. For -o, predicates that are likely to succeed are evaluated earlier, and for -a, predicates that are likely to fail are evaluated earlier.
The cost-based optimiser has a fixed idea of how likely any given test is to succeed. In some cases the probability takes account of the specific nature of the test (for example, -type f is assumed to be more likely to succeed than -type c). The cost-based optimiser is currently being evaluated. If it does not actually improve the performance of find, it will be removed again. Conversely, optimisations that prove to be reliable, robust and effective may be enabled at lower optimisation levels over time. However, the default behaviour (i.e. optimisation level 1) will not be changed in the 4.3.x release series. The findutils test suite runs all the tests on find at each optimisation level and ensures that the result is the same.</p>
<h2 id="expressions">Expressions</h2>
<p>The expression is made up of options (which affect overall operation rather than the processing of a specific file, and always return true), tests (which return a true or false value), and actions (which have side effects and return a true or false value), all separated by operators. -and is assumed where the operator is omitted.</p>
<p>If the expression contains no actions other than -prune, -print is performed on all files for which the expression is true.</p>
<h2 id="expression-options">Expression Options</h2>
<p>All options always return true. Except for -daystart, -follow and -regextype, the options affect all tests, including tests specified before the option. This is because the options are processed when the command line is parsed, while the tests don't do anything until files are examined. The -daystart, -follow and -regextype options are different in this respect, and have an effect only on tests which appear later in the command line. Therefore, for clarity, it is best to place them at the beginning of the expression. A warning is issued if you don't do this.</p>
<p>-d  A synonym for -depth, for compatibility with FreeBSD, NetBSD, OpenBSD, and MacOS X.
-daystart   Measure times (for -amin, -atime, -cmin, -ctime, -mmin, and -mtime) from the beginning of today rather than from 24 hours ago. This option only affects tests which appear later on the command line.
-depth  Process each directory's contents before the directory itself. The -delete action also implies -depth.
-follow This option is an older way to do the same thing as -L. It is now deprecated; you should use the -L option instead.</p>
<p>This option dereferences symbolic links and implies -noleaf. The -follow option affects only those tests which appear after it on the command line. Unless the -H or -L option has been specified, the position of the -follow option changes the behaviour of the -newer predicate; any files listed as the argument of -newer will be dereferenced if they are symbolic links. The same consideration applies to -newerXY, -anewer and -cnewer. Similarly, the -type predicate will always match against the type of the file that a symbolic link points to rather than the link itself. Using -follow causes the -lname and -ilname predicates always to return false.
-help, --help   Print a help message, and exit.
-ignore_readdir_race    Normally, find gives an error message when it cannot stat a file. If you give this option and a file is deleted between the time find reads the name of the file from the directory and the time it tries to stat the file, no error message will be issued. This also applies to paths given on the command line. This option takes effect at the time the command line is read, which means that you cannot search one part of the filesystem with this option on and part of it with this option off.
-maxdepth levels    Descend at most levels (a non-negative integer) levels of directories below the command line arguments. -maxdepth 0 means only apply the tests and actions to the paths specified on the command line, and do not descend into subdirectories at all.
-mindepth levels    Do not apply any tests or actions at levels less than levels (a non-negative integer). -mindepth 1 means process all files except the command line arguments.
-mount  Don't descend directories on other filesystems. An alternate name for -xdev. This option is provided for compatibility with some other versions of find.
-noignore_readdir_race  Turns off the effect of -ignore_readdir_race.
-noleaf Do not optimize by assuming that directories contain 2 fewer subdirectories than their hard link count. This option is needed when searching filesystems that do not follow the Unix directory-link convention, such as CD-ROM or MS-DOS filesystems, or AFS volume mount points. Each directory on a normal Unix filesystem has at least 2 hard links: its name and its '.' entry. Additionally, its subdirectories (if any) each have a '..' entry linked to that directory. When find is examining a directory, after it has statted 2 fewer subdirectories than the directory's link count, it knows that the rest of the entries in the directory are non-directories ('leaf' files in the directory tree). If only the files' names need to be examined, there is no need to stat them; this gives a significant increase in search speed.</p>
<p>If you are using a standard linux filesystem, you should not need to use this option.
-regextype type Changes the regular expression syntax understood by -regex and -iregex tests which occur later on the command line. Currently-implemented types are emacs (this is the default), posix-awk, posix-basic, posix-egrep and posix-extended.</p>
<p>If you're using a specific style of regular expression syntax, you may need to specify this option. Otherwise, it should be unnecessary.
-version, --version Print the find version number and exit.
-warn, -nowarn  Turn warning messages on or off. These warnings apply only to the command line usage, not to any conditions that find might encounter when it searches directories. The default behaviour corresponds to -warn if standard input is a tty, and to -nowarn otherwise.
-xdev   Don't descend directories on other filesystems.</p>
<h2 id="tests">Tests</h2>
<p>Some tests, for example -newerXY and -samefile, allow comparison between the file currently being examined and some reference file specified on the command line. When these tests are used, the interpretation of the reference file is determined by the options -H, -L and -P and any previous -follow, but the reference file is only examined once, at the time the command line is parsed. If the reference file cannot be examined (for example, the stat system call fails for it), an error message is issued, and find exits with a nonzero status.</p>
<p>Where n is used as a numeric argument, it can be specified as:</p>
<p>+n  For greater than n.
-n  For less than n.
n   For exactly n.
Tests are as follows:</p>
<p>-amin n Returns true is a file was last accessed n minutes ago.
-anewer file    Returns true if a file was last accessed more recently than file was modified. If file is a symbolic link and the -H option or the -L option is in effect, the access time of the file it points to is always used.
-atime n    Returns true if a file was last accessed n * 24 hours ago. When find figures out how many 24-hour periods ago the file was last accessed, any fractional part is ignored, so to match -atime +1, a file has to have been accessed at least two days ago.
-cmin n Returns true if a file's status was last changed n minutes ago.
-cnewer file    Returns true if a file's status was last changed more recently than file was modified. If file is a symbolic link and the -H option or the -L option is in effect, the status-change time of the file it points to is always used.
-ctime n    Returns true if a file's status was last changed n<em>24 hours ago. See the comments for -atime to understand how rounding affects the interpretation of file status change times.
-empty  Returns true if a file is empty (contains nothing) and is either a regular file or a directory.
-executable Matches files that are executable and directories that are searchable (in a file name resolution sense). This takes into account access control lists and other permissions artefacts which the -perm test ignores. This test makes use of the access system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement access in the client's kernel and so cannot make use of the UID mapping information held on the server. Because this test is based only on the result of the access system call, there is no guarantee that a file for which this test succeeds can actually be executed.
-false  When used as part of an expression, -false always evaluates as false.
-fstype type    Returns true if a file is on a filesystem of type type. The valid filesystem types vary among different versions of Unix; an incomplete list of filesystem types that are accepted on some version of Unix or another is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K. You can use -printf with the %F directive to see the types of your filesystems.
-gid n  Returns true if a file's numeric group ID is n.
-group gname    Returns true if a file belongs to group gname (numeric group IDs are allowed).
-ilname pattern Like -lname, but the match is case insensitive. If the -L option or the -follow option is in effect, this test returns false unless the symbolic link is broken.
-iname pattern  Like -name, but the match is case insensitive. For example, the patterns 'fo</em>' and 'F??' match the file names 'Foo', 'FOO', 'foo', 'fOo', etc. In these patterns, unlike file name expansion by the shell, an initial '.' can be matched by '<em>'. That is, find -name </em>bar will match the file '.foobar'. Please note that you should always quote patterns, otherwise the shell will expand any wildcard characters in them.
-inum n Returns true if a file has inode number n. It is normally easier to use the -samefile test instead.
-ipath pattern  Behaves in the same way as -iwholename. This option is deprecated, so you should no longer use it.
-iregex pattern Like -regex, but the match is case-insensitive.
-iwholename pattern Like -wholename, but the match is case-insensitive.
-links n    Returns true if a file has n links.
-lname pattern  Returns true if a file is a symbolic link whose contents match shell pattern pattern. The metacharacters do not treat '/' or '.' specially. If the -L option or the -follow option is in effect, this test returns false unless the symbolic link is broken.
-mmin n Returns true if the file's data was last modified n minutes ago.
-mtime n    Returns true if a file's data was last modified n * 24 hours ago. See the -atime option to understand how rounding affects the interpretation of file modification times.
-name pattern   Returns true if the base of a file name (the path with the leading directories removed) matches shell pattern pattern. The metacharacters ('*', '?', and '[ ]') match a '.' at the start of the base name. To ignore a directory and the files under it, use -prune; see an example in the description of -path. Braces are not recognised as being special, despite the fact that some shells including bash imbue braces with a special meaning in shell patterns. The file name matching is performed with the use of the fnmatch library function. Don't forget to enclose the pattern in quotes to protect it from expansion by the shell.
-newer file Returns true if a file was modified more recently than the file file. If file is a symbolic link and the -H option or the -L option is in effect, the modification time of the file it points to is always used.
-newerXY reference<br />
Compares the timestamp of the current file with reference. The reference argument is normally the name of a file (and one of its timestamps is used for the comparison) but it may also be a string describing an absolute time. X and Y are placeholders for other letters, and these letters select which time belonging to how reference is used for the comparison.</p>
<p>a   The access time of the file reference
B   The birth time of the file reference
c   The inode status change time of reference
m   The modification time of the file reference
t   reference is interpreted directly as a time
Some combinations are invalid; for example, it is invalid for X to be t. Some combinations are not implemented on all systems; for example B is not supported on all systems. If an invalid or unsupported combination of XY is specified, a fatal error results. Time specifications are interpreted as for the argument to the -d option of GNU date. If you try to use the birth time of a reference file, and the birth time cannot be determined, a fatal error message results. If you specify a test which refers to the birth time of files being examined, this test will fail for any files where the birth time is unknown.
-nogroup    Returns tue if no existing group corresponds to file's numeric group ID.
-nouser Returns true if no existing user corresponds to file's numeric user ID.
-path pattern   Returns true if a file name matches shell pattern pattern. The metacharacters do not treat '/' or '.' specially; so, for example,</p>
<p>find . -path "./sr*sc"
will print an entry for a directory called './src/misc' (if one exists). To ignore a whole directory tree, use -prune rather than checking every file in the tree. For example, to skip the directory 'src/emacs' and all files and directories under it, and print the names of the other files found, do something like this:</p>
<p>find . -path ./src/emacs -prune -o -print
Note that the pattern match test applies to the whole file name, starting from one of the start points named on the command line. It would only make sense to use an absolute pathname here if the relevant start point is also an absolute path. This means that this command will never match anything:</p>
<p>find bar -path /foo/bar/myfile -print
The predicate -path is also supported by HP-UX find and will be in a forthcoming version of the POSIX standard.
-perm mode  Returns true if a file's permission bits are exactly mode (octal or symbolic). Since an exact match is required, if you want to use this form for symbolic modes, you may have to specify a rather complex mode string. For example -perm g=w will only match files which have mode 0020 (that is, ones for which group write permission is the only permission set). It is more likely that you will want to use the '/' or '-' forms, for example -perm -g=w, which matches any file with group write permission.
-perm -mode Returns true if all of the permission bits of mode are set for the file. Symbolic modes are accepted in this form, and this is usually the way in which would want to use them. You must specify 'u', 'g' or 'o' if you use a symbolic mode.
-perm /mode Returns true if any of the permission bits of mode are set for the file. Symbolic modes are accepted in this form. You must specify 'u', 'g' or 'o' if you use a symbolic mode. If no permission bits in mode are set, this test matches any file.
-perm +mode Deprecated; this is the old way of searching for files with any of the permission bits in mode. You should use -perm /mode instead. Trying to use the '+' syntax with symbolic modes will yield unexpected results.
-readable   Matches files that are readable. This takes into account access control lists and other permissions factors which the -perm test ignores. This test makes use of the access system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement access in the client's kernel and so cannot make use of the UID mapping information held on the server.
-regex pattern  Returns true if a file name matches the regular expression pattern. This is a match on the whole path, not just the file name. For example, to match a file named './fubar3', you can use the regular expression '.<em>bar.' or '.</em>b.<em>3', but not 'f.</em>r3' (because the complete path does not begin with an f). The regular expressions understood by find are by default Emacs regular expressions, but this can be changed with the -regextype option (see above).
- samefile name Returns true if a file refers to the same inode as name. When -L is in effect, this can include symbolic links.
-size [-|+]n[cwbkMG]  <br />
Returns true if a file uses n units of space on the disk. If preceded by a minus sign ("-"), matches files which use less space; if preceded by a plus sign ("+"), matches files which use more. The following suffixes can be used to abbreviate units:</p>
<p>b   for 512-byte blocks (this is the default if no suffix is used)
c   for bytes
w   for two-byte words
k   for Kilobytes (units of 1024 bytes)
M   for Megabytes (units of 1048576 bytes)
G   for Gigabytes (units of 1073741824 bytes)
The size does not count indirect blocks, but it does count blocks in sparse files that are not actually allocated. You should note that the '%k' and '%b' format specifiers of -printf handle sparse files differently. The 'b' suffix always denotes 512-byte blocks and never 1 Kilobyte blocks, which is different than the behaviour of -ls.
-true   When used in an expression, -true always returns true.
-type c 
Returns true if a file is of type c:</p>
<p>b   block (buffered) special files
c   character (unbuffered) special files
d   directories
p   named pipes (FIFOs)
f   regular files
l   symbolic links. This is never true if the -L option or the -follow option has been specified, unless the symbolic link is broken. If you want to search for symbolic links when -L is in effect, use -xtype.
s   sockets
D   doors (a Solaris file type)
-uid n  Returns true if a file's numeric user ID is n.
-used n Returns true if a file was last accessed n days after its status was last changed.
-user uname Returns true if a file is owned by user uname (numeric user IDs are allowed).
-wholename pattern  Functionally the same as -path. This alternative is less portable than -path, however; for greatest compliance across different types of systems, you should use -path instead.
-writable   Matches files that are writable. This takes into account access control lists and other permissions factors which the -perm test ignores. This test makes use of the access system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement access in the client's kernel and so cannot make use of the UID mapping information held on the server.
-xtype c    The same as -type unless the file is a symbolic link. For symbolic links: if the -H or -P option was specified, returns true if the file is a link to a file of type c; if the -L option has been given, returns true if c is 'l'. In other words, for symbolic links, -xtype checks the type of the file that -type does not check.</p>
<h2 id="actions">Actions</h2>
<p>-delete Delete matched files; returns true if removal succeeded. If the removal failed, an error message is issued. If -delete fails, find's exit status will be nonzero (when it eventually exits). Use of -delete automatically turns on the -depth option.</p>
<p>Don't forget that the find command line is evaluated as an expression, so putting -delete first will make find try to delete everything below the starting points you specified. When testing a find command line that you later intend to use with -delete, you should explicitly specify -depth to avoid later surprises. Because -delete implies -depth, you cannot usefully use -prune and -delete together.
-exec command ; Execute command on each matched file; returns true if 0 is returned as the exit status of command. All following arguments to find are taken to be arguments to the command until a semicolon (';') is encountered. The string '{}' is replaced by the current file name being processed everywhere it occurs in the arguments to the command, not just in arguments where it is alone, as in some versions of find. Both of these constructions might need to be escaped (with a '\') or quoted to protect them from expansion by the shell. The specified command is run once for each matched file. The command is executed in the starting directory. There are unavoidable security problems surrounding use of -exec; you should use the -execdir option instead.
-exec command {} +  This variant of the -exec action runs the specified command on the selected files, but the command line is built by appending each selected file name at the end; the total number of invocations of the command will be much less than the number of matched files. The command line is built in much the same way that xargs builds its command lines. Only one instance of '{}' is allowed within the command. The command is executed in the starting directory.
-execdir command ;
by an unpredictable order of system operations) during resolution of the paths to the matched files. As with the -exec action, the '+' form of -execdir will build a command line to process more than one matched file, but any given invocation of command will only list files that exist in the same subdirectory. If you use this option, you must ensure that your $PATH environment variable does not reference '.'; otherwise, an attacker can run any commands they like by leaving an appropriately-named file in a directory in which you will run -execdir. The same applies to having entries in $PATH that are empty or not absolute directory names.
-fls file   Returns true; behaves like -ls, but writes to file like -fprint. The output file is always created, even if no match is found.
-fprint file    Returns true; prints the full file name into file file. If file does not exist when find is run, it is created; if it does exist, it is truncated. The file names "/dev/stdout" and "/dev/stderr" are handled specially; they refer to the standard output and standard error output, respectively. The output file is always created, even if the predicate is never matched.
-fprint0 file   Returns true; like -print0 but writes to file like -fprint. The output file is always created, even if no match is found.
-fprintf file format    Returns true; like -printf, but writes to file like -fprint. The output file is always created, even if the predicate is never matched.
-ls Returns true; lists current file in ls -dils format (see ls for details) on standard output. The block counts are of 1K blocks, unless the environment variable POSIXLY_CORRECT is set, in which case 512-byte blocks are used.
-ok command ;   Like -exec, but asks the user first. If the user agrees, find runs the command. Otherwise, it returns false. If the command is run, its standard input is redirected from /dev/null.</p>
<p>The response to the prompt is matched against a pair of regular expressions to determine if it is an affirmative or negative response. This regular expression is obtained from the system if the 'POSIXLY_CORRECT' environment variable is set, or otherwise from find's message translations. If the system has no suitable definition, find's own definition will be used. In either case, the interpretation of the regular expression itself will be affected by the environment variables 'LC_CTYPE' (character classes) and 'LC_COLLATE' (character ranges and equivalence classes).
-okdir command ;    Like -execdir but asks the user first in the same way as for -ok. If the user does not agree, returns false. If the command is run, its standard input is redirected from /dev/null.
-print  Returns true; prints the full file name on the standard output, followed by a newline. If you are piping the output of find into another program and there is the faintest possibility that the files which you are searching for might contain a newline, then you should consider using the -print0 option instead of -print.
-print0 Returns true; prints the full file name on the standard output, followed by a null character (instead of the newline character that -print uses). This allows file names that contain newlines or other types of white space to be correctly interpreted by programs that process the find output. This option corresponds to the -0 option of xargs.
-printf format<br />
Returns true; prints format on the standard output, interpreting '\' escapes and '%' directives. Field widths and precisions can be specified as with the 'printf' C function. Please note that many of the fields are printed as %s rather than %d, and this may mean that flags don't work as you might expect. This also means that the '-' flag does work (it forces fields to be left-aligned). Unlike -print, -printf does not add a newline at the end of the string. The escapes and directives are:</p>
<p>\a  Alarm bell.
\b  Backspace.
\c  Stop printing using format immediately and flush the remaining output.
\f  Form feed.
\n  Newline.
\r  Carriage return.
\t  Horizontal tab.
\v  Vertical tab.
\0  The ASCII NUL character.
\  A literal backslash ('\').
\NNN    The character whose ASCII code is NNN (where NNN is an octal value).
A '\' character followed by any other character is treated as an ordinary character, so they both are printed.</p>
<p>%%  A literal percent sign.
%a  The file's last access time in the format returned by the C ctime function.
%Ak 
The file's last access time in the format specified by k, which is either '@' or a directive of the C 'strftime' function. The possible values for k are listed below; some of them might not be available on all systems, due to differences in strftime between systems.</p>
<p>Values for k can be one of the following:</p>
<p>@   seconds since Jan. 1, 1970, 00:00 GMT, with fractional part.
Time fields:</p>
<p>H   hour (00..23)
I   hour (01..12)
k   hour ( 0..23)
l   hour ( 1..12)
M   minute (00..59)
p   locale's AM or PM
r   time, 12-hour (hh:mm:ss [AP]M)
S   Second (00.00 .. 61.00). There is a fractional part.
T   time, 24-hour (hh:mm:ss)
+   Date and time, separated by '+', for example '2004-04-28+22:22:05.0'. This is a GNU extension. The time is given in the current timezone (which may be affected by setting the TZ environment variable). The seconds field includes a fractional part.
X   locale's time representation (H:M:S)
Z   time zone (e.g., EDT), or nothing if no time zone is determinable
Date fields:</p>
<p>a   locale's abbreviated weekday name (Sun..Sat)
A   locale's full weekday name, variable length (Sunday..Saturday)
b   locale's abbreviated month name (Jan..Dec)
B   locale's full month name, variable length (January..December)
c   locale's date and time (Sat Nov 04 12:02:33 EST 1989). The format is the same as for ctime and so to preserve compatibility with that format, there is no fractional part in the seconds field.
d   day of month (01..31)
D   date (mm/dd/yy)
h   same as b
j   day of year (001..366)
m   month (01..12)
U   week number of year with Sunday as first day of week (00..53)
w   day of week (0..6)## 
W   week number of year with Monday as first day of week (00..53)
x   locale's date representation (mm/dd/yy)
y   last two digits of year (00..99)
Y   year (1970..)
%b  The amount of disk space used for this file in 512-byte blocks. Since disk space is allocated in multiples of the filesystem block size this is usually greater than %s/512, but it can also be smaller if the file is a sparse file.
%c  File's last status change time in the format returned by the C 'ctime' function.
%Ck File's last status change time in the format specified by k, which is the same as for %A.
%d  File's depth in the directory tree; 0 means the file is a command line argument.
%D  The device number on which the file exists (the st_dev field of struct stat), in decimal.
%f  File's name with any leading directories removed (only the last element).
%F  Type of the filesystem the file is on; this value can be used for -fstype.
%g  File's group name, or numeric group ID if the group has no name.
%G  File's numeric group ID.
%h  Leading directories of file's name (all but the last element). If the file name contains no slashes (since it is in the current directory) the %h specifier expands to ".".
%H  Command line argument under which file was found.
%i  File's inode number (in decimal).
%k  The amount of disk space used for this file in 1K blocks. Since disk space is allocated in multiples of the filesystem block size this is usually greater than %s/1024, but it can also be smaller if the file is a sparse file.
%l  Object of symbolic link (empty string if file is not a symbolic link).
%m  File's permission bits (in octal). This option uses the 'traditional' numbers which most Unix implementations use, but if your particular implementation uses an unusual ordering of octal permissions bits, you will see a difference between the actual value of the file's mode and the output of %m. Normally you will want to have a leading zero on this number, and to do this, you should use the # flag (as in, for example, '%#m').
%M  File's permissions (in symbolic form, as for ls).
%n  Number of hard links to file.
%p  File's name.
%P  File's name with the name of the command line argument under which it was found removed.
%s  File's size in bytes.
%S  File's sparseness. This is calculated as (BLOCKSIZE*st_blocks / st_size). The exact value you will get for an ordinary file of a certain length is system-dependent. However, normally sparse files will have values less than 1.0, and files which use indirect blocks may have a value that is greater than 1.0. The value used for BLOCKSIZE is system-dependent, but is usually 512 bytes. If the file size is zero, the value printed is undefined. On systems which lack support for st_blocks, a file's sparseness is assumed to be 1.0.
%t  File's last modification time in the format returned by the C 'ctime' function.
%Tk File's last modification time in the format specified by k, which is the same as for %A.
%u  File's user name, or numeric user ID if the user has no name.
%U  File's numeric user ID.
%y  File's type (like in ls -l). U=unknown type (although this shouldn't happen)
%Y  File's type (like %y), plus follow symlinks: L=loop, N=nonexistent
A '%' character followed by any other character is discarded, but the other character is printed (but don't rely on this, as further format characters may be introduced). A '%' at the end of the format argument causes undefined behaviour since there is no following character. In some locales, it may hide your door keys, while in others it may remove the final page from the novel you are reading.</p>
<p>The %m and %d directives support the # , 0 and + flags, but the other directives do not, even if they print numbers. Numeric directives that do not support these flags include G, U, b, D, k and n. The '-' format flag is supported and changes the alignment of a field from right-justified (which is the default) to left-justified.</p>
<p>-prune  True; if the file is a directory, do not descend into it. If -depth is given, false; no effect. Because -delete implies -depth, you cannot usefully use -prune and -delete together.
-quit   Exit immediately. No child processes will be left running, but no more paths specified on the command line will be processed. For example, find /tmp/foo /tmp/bar -print -quit will print only /tmp/foo. Any command lines which have been built up with -execdir ... {} + will be invoked before find exits. The exit status may or may not be zero, depending on whether an error has already occurred.</p>
<h2 id="handling-unusual-file-names">Handling Unusual File Names</h2>
<p>Many of the actions of find result in the printing of data that is under the control of other users. This includes file names, sizes, modification times and so forth. File names are a potential problem since they can contain any character except '\0' and '/'. Unusual characters in file names can do unexpected and often undesirable things to your terminal (for example, changing the settings of your function keys on some terminals). Unusual characters are handled differently by various actions, as described below:</p>
<p>-print0, -fprint0   Always print the exact file name, unchanged, even if the output is going to a terminal.
-ls, -fls   Unusual characters are always escaped. White space, backslash, and double quote characters are printed using C-style escaping (for example '\f', '\"'). Other unusual characters are printed using an octal escape. Other printable characters (for -ls and -fls these are the characters between octal 041 and 0176) are printed as is.
-printf, -fprintf   If the output is not going to a terminal, it is printed as is. Otherwise, the result depends on which directive is in use. The directives %D, %F, %g, %G, %H, %Y, and %y expand to values that are not under control of files' owners, and so are printed as is. The directives %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u and %U have values that are under the control of files' owners but which cannot be used to send arbitrary data to the terminal, and so these are printed as is. The directives %f, %h, %l, %p and %P are quoted. This quoting is performed in the same way as for GNU ls. This is not the same quoting mechanism as the one used for -ls and -fls. If you can decide what format to use for the output of find then it is normally better to use '\0' as a terminator than to use newline, as file names can contain white space and newline characters. The setting of the 'LC_CTYPE' environment variable is used to determine which characters need to be quoted.
-print, -fprint Quoting is handled in the same way as for -printf and -fprintf. If you are using find in a script or in a situation where the matched files might have arbitrary names, you should consider using -print0 instead of -print.
The -ok and -okdir actions print the current file name as is.</p>
<h2 id="operators">Operators</h2>
<p>The following find operators are listed in order of increasing precedence:</p>
<p>( expr )    Force precedence. Since parentheses are special to the shell, you will normally need to quote them. For instance, you will probably need to specify '(...)' instead of '(...)'.
! expr  Returns true if expr is false. This character will also usually need protection from interpretation by the shell.
-not expr   Same as ! expr, but not POSIX compliant.
expr1 expr2 Two expressions in a row are taken to be joined with an implied "and"; in other words, expr2 is not evaluated if expr1 is false.
expr1 -a expr2  Same as expr1 expr2.
expr1 -and expr2    Same as expr1 expr2, but not POSIX compliant.
expr1 -o expr2  Boolean OR; in other words, expr2 is not evaluated if expr1 is true.
expr1 -or expr2 Same as expr1 -o expr2, but not POSIX compliant.
expr1 , expr2   Separating two expressions with a comma treats them as a list: both expr1 and expr2 are always evaluated. The value of expr1 is discarded in the return value; the value of the list is the value of expr2. The comma operator can be useful for searching for different types of thing, but traversing the filesystem hierarchy only once. The -fprintf action can be used to list the various matched items into different output files.</p>
<h2 id="environment-variables">Environment Variables</h2>
<p>LANG    Provides a default value for the internationalization variables that are unset or null.
LC_ALL  If set to a non-empty string value, this variable's value overrides the values of all the other internationalization variables.
LC_COLLATE  The POSIX standard specifies that this variable affect the pattern matching to be used for the -name option. GNU find uses the fnmatch library function, and so support for 'LC_COLLATE' depends on the system library. This variable also affects the interpretation of the response to -ok; while the 'LC_MESSAGES' variable selects the actual pattern used to interpret the response to -ok, the interpretation of any bracket expressions in the pattern will be affected by 'LC_COLLATE'.
LC_CTYPE    This variable affects the treatment of character classes used in regular expressions and also with the -name test, if the system's fnmatch library function supports this. This variable also affects the interpretation of any character classes in the regular expressions used to interpret the response to the prompt issued by -ok. The 'LC_CTYPE' environment variable will also affect which characters are considered to be unprintable when file names are printed.
LC_MESSAGES Determines the locale to be used for internationalised messages. If the 'POSIXLY_CORRECT' environment variable is set, this also determines the interpretation of the response to the prompt made by the -ok action.
NLSPATH Determines the location of the internatDescription
find locates files on your system. Within each directory tree specified by the given paths, it evaluates the given expression from left to right, according to the rules of precedence (see "Operators", below) until the outcome is known. The outcome is "known" when the left hand side of the expression is determined to be FALSE for AND operations, or TRUE for OR operations. At that point find moves on to the next path until all paths have been searched.</p>
<p>find is a fundamental and extremely powerful tool for working with the files on your linux system. It can be used on its own to locate files, or in conjunction with other programs to perform operations on those files.</p>
<h2 id="syntax_1">Syntax</h2>
<p>find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]
Options
The -H, -L and -P options control the treatment of symbolic links. Arguments following these are taken to be names of files or directories to be examined, up to the first argument that begins with "-", or the argument "(" or "!". That argument and any following arguments are taken to be the expression describing what is being searched. If no paths are given, the current directory is used. If no expression is given, the expression -print is used (but you should probably consider using -print0 instead, anyway. More information on this below).</p>
<p>The arguments in the expression list are also referred to as "options," but the five "real" options -H, -L, -P, -D and -O must appear before the first path name, if they are used at all. A double-dash ("--") can also be used to signal that any remaining arguments are not options (though ensuring that all start points begin with either "./" or "/" is generally safer if you use wildcards in the list of start points).</p>
<p>-P  Never follow symbolic links. This is the default. When find examines or prints information a file, and the file is a symbolic link, the information used will be taken from the properties of the symbolic link itself.
-L  Follow symbolic links. When find examines or prints information about files, the information used will be taken from the properties of the file to which the link points, not from the link itself (unless it is a broken symbolic link or find is unable to examine the file to which the link points). Use of this option implies -noleaf. If you later use the -P option, -noleaf will still be in effect. If -L is in effect and find discovers a symbolic link to a subdirectory during its search, the subdirectory pointed to by the symbolic link will be searched.</p>
<p>When the -L option is in effect, the -type predicate will always match against the type of the file that a symbolic link points to rather than the link itself (unless the symbolic link is broken). Using -L causes the -lname and -ilname predicates always to return false.
-H  Do not follow symbolic links, except while processing the command line arguments. When find examines or prints information about files, the information used will be taken from the properties of the symbolic link itself. The only exception to this behaviour is when a file specified on the command line is a symbolic link, and the link can be resolved. For that situation, the information used is taken from whatever the link points to (that is, the link is followed). The information about the link itself is used as a fallback if the file pointed to by the symbolic link cannot be examined. If -H is in effect and one of the paths specified on the command line is a symbolic link to a directory, the contents of that directory will be examined (though specifying -maxdepth 0 would prevent this).
If more than one of -H, -L and -P is specified, each overrides the others; the last one appearing on the command line takes effect. Since it is the default, the -P option should be considered to be in effect unless either -H or -L is specified. GNU find frequently stats files during the processing of the command line itself, before any searching has begun. These options also affect how those arguments are processed. Specifically, there are a number of tests that compare files listed on the command line against a file we are currently considering. In each case, the file specified on the command line will have been examined and some of its properties will have been saved. If the named file is in fact a symbolic link, and the -P option is in effect (or if neither -H nor -L were specified), the information used for the comparison will be taken from the properties of the symbolic link. Otherwise, it will be taken from the properties of the file the link points to. If find cannot follow the link (for example because it has insufficient privileges or the link points to a nonexistent file) the properties of the link itself will be used.</p>
<p>When the -H or -L options are in effect, any symbolic links listed as the argument of -newer will be dereferenced, and the timestamp will be taken from the file to which the symbolic link points. The same consideration applies to -newerXY, -anewer and -cnewer.</p>
<p>The -follow option has a similar effect to -L, though it takes effect at the point where it appears (that is, if -L is not used but -follow is, any symbolic links appearing after -follow on the command line will be dereferenced, and those before it will not).</p>
<p>-D debugoptions 
Print diagnostic information; this can be helpful to diagnose problems with why find is not doing what you want. The list of debug options should be comma separated. Compatibility of the debug options is not guaranteed between releases of findutils. For a complete list of valid debug options, see the output of find -D help. Valid debug options include:</p>
<p>help    Explain the debugging options.
tree    Show the expression tree in its original and optimised form.
stat    Print messages as files are examined with the stat and lstat system calls. The find program tries to minimize such calls.
opt Prints diagnostic information relating to the optimisation of the expression tree; see the -O option.
rates   Prints a summary indicating how often each predicate succeeded or failed.
-Olevel 
Enables query optimisation. The find program reorders tests to speed up execution while preserving the overall effect; that is, predicates with side effects are not reordered relative to each other. The optimisations performed at each optimisation level are as follows.</p>
<p>There must not be a space in between -O and the decimal representing the optimization level. The decimals and their meanings are as follows:</p>
<p>0   Equivalent to optimisation level 1.
1   This is the default optimisation level and corresponds to the traditional behaviour. Expressions are reordered so that tests based only on the names of files (for example -name and -regex) are performed first.
2   Any -type or -xtype tests are performed after any tests based only on the names of files, but before any tests that require information from the inode. On many modern versions of Unix, file types are returned by readdir() and so these predicates are faster to evaluate than predicates which need to stat the file first.
3   At this optimisation level, the full cost-based query optimiser is enabled. The order of tests is modified so that cheap (i.e. fast) tests are performed first and more expensive ones are performed later, if necessary. Within each cost band, predicates are evaluated earlier or later according to whether they are likely to succeed or not. For -o, predicates that are likely to succeed are evaluated earlier, and for -a, predicates that are likely to fail are evaluated earlier.
The cost-based optimiser has a fixed idea of how likely any given test is to succeed. In some cases the probability takes account of the specific nature of the test (for example, -type f is assumed to be more likely to succeed than -type c). The cost-based optimiser is currently being evaluated. If it does not actually improve the performance of find, it will be removed again. Conversely, optimisations that prove to be reliable, robust and effective may be enabled at lower optimisation levels over time. However, the default behaviour (i.e. optimisation level 1) will not be changed in the 4.3.x release series. The findutils test suite runs all the tests on find at each optimisation level and ensures that the result is the same.
Expressions
The expression is made up of options (which affect overall operation rather than the processing of a specific file, and always return true), tests (which return a true or false value), and actions (which have side effects and return a true or false value), all separated by operators. -and is assumed where the operator is omitted.</p>
<p>If the expression contains no actions other than -prune, -print is performed on all files for which the expression is true.</p>
<p>Expression Options
All options always return true. Except for -daystart, -follow and -regextype, the options affect all tests, including tests specified before the option. This is because the options are processed when the command line is parsed, while the tests don't do anything until files are examined. The -daystart, -follow and -regextype options are different in this respect, and have an effect only on tests which appear later in the command line. Therefore, for clarity, it is best to place them at the beginning of the expression. A warning is issued if you don't do this.</p>
<p>-d  A synonym for -depth, for compatibility with FreeBSD, NetBSD, OpenBSD, and MacOS X.
-daystart   Measure times (for -amin, -atime, -cmin, -ctime, -mmin, and -mtime) from the beginning of today rather than from 24 hours ago. This option only affects tests which appear later on the command line.
-depth  Process each directory's contents before the directory itself. The -delete action also implies -depth.
-follow This option is an older way to do the same thing as -L. It is now deprecated; you should use the -L option instead.</p>
<p>This option dereferences symbolic links and implies -noleaf. The -follow option affects only those tests which appear after it on the command line. Unless the -H or -L option has been specified, the position of the -follow option changes the behaviour of the -newer predicate; any files listed as the argument of -newer will be dereferenced if they are symbolic links. The same consideration applies to -newerXY, -anewer and -cnewer. Similarly, the -type predicate will always match against the type of the file that a symbolic link points to rather than the link itself. Using -follow causes the -lname and -ilname predicates always to return false.
-help, --help   Print a help message, and exit.
-ignore_readdir_race    Normally, find gives an error message when it cannot stat a file. If you give this option and a file is deleted between the time find reads the name of the file from the directory and the time it tries to stat the file, no error message will be issued. This also applies to paths given on the command line. This option takes effect at the time the command line is read, which means that you cannot search one part of the filesystem with this option on and part of it with this option off.
-maxdepth levels    Descend at most levels (a non-negative integer) levels of directories below the command line arguments. -maxdepth 0 means only apply the tests and actions to the paths specified on the command line, and do not descend into subdirectories at all.
-mindepth levels    Do not apply any tests or actions at levels less than levels (a non-negative integer). -mindepth 1 means process all files except the command line arguments.
-mount  Don't descend directories on other filesystems. An alternate name for -xdev. This option is provided for compatibility with some other versions of find.
-noignore_readdir_race  Turns off the effect of -ignore_readdir_race.
-noleaf Do not optimize by assuming that directories contain 2 fewer subdirectories than their hard link count. This option is needed when searching filesystems that do not follow the Unix directory-link convention, such as CD-ROM or MS-DOS filesystems, or AFS volume mount points. Each directory on a normal Unix filesystem has at least 2 hard links: its name and its '.' entry. Additionally, its subdirectories (if any) each have a '..' entry linked to that directory. When find is examining a directory, after it has statted 2 fewer subdirectories than the directory's link count, it knows that the rest of the entries in the directory are non-directories ('leaf' files in the directory tree). If only the files' names need to be examined, there is no need to stat them; this gives a significant increase in search speed.</p>
<p>If you are using a standard linux filesystem, you should not need to use this option.
-regextype type Changes the regular expression syntax understood by -regex and -iregex tests which occur later on the command line. Currently-implemented types are emacs (this is the default), posix-awk, posix-basic, posix-egrep and posix-extended.</p>
<p>If you're using a specific style of regular expression syntax, you may need to specify this option. Otherwise, it should be unnecessary.
-version, --version Print the find version number and exit.
-warn, -nowarn  Turn warning messages on or off. These warnings apply only to the command line usage, not to any conditions that find might encounter when it searches directories. The default behaviour corresponds to -warn if standard input is a tty, and to -nowarn otherwise.
-xdev   Don't descend directories on other filesystems.
Tests
Some tests, for example -newerXY and -samefile, allow comparison between the file currently being examined and some reference file specified on the command line. When these tests are used, the interpretation of the reference file is determined by the options -H, -L and -P and any previous -follow, but the reference file is only examined once, at the time the command line is parsed. If the reference file cannot be examined (for example, the stat system call fails for it), an error message is issued, and find exits with a nonzero status.</p>
<p>Where n is used as a numeric argument, it can be specified as:</p>
<p>+n  For greater than n.
-n  For less than n.
n   For exactly n.
Tests are as follows:</p>
<p>-amin n Returns true is a file was last accessed n minutes ago.
-anewer file    Returns true if a file was last accessed more recently than file was modified. If file is a symbolic link and the -H option or the -L option is in effect, the access time of the file it points to is always used.
-atime n    Returns true if a file was last accessed n * 24 hours ago. When find figures out how many 24-hour periods ago the file was last accessed, any fractional part is ignored, so to match -atime +1, a file has to have been accessed at least two days ago.
-cmin n Returns true if a file's status was last changed n minutes ago.
-cnewer file    Returns true if a file's status was last changed more recently than file was modified. If file is a symbolic link and the -H option or the -L option is in effect, the status-change time of the file it points to is always used.
-ctime n    Returns true if a file's status was last changed n<em>24 hours ago. See the comments for -atime to understand how rounding affects the interpretation of file status change times.
-empty  Returns true if a file is empty (contains nothing) and is either a regular file or a directory.
-executable Matches files that are executable and directories that are searchable (in a file name resolution sense). This takes into account access control lists and other permissions artefacts which the -perm test ignores. This test makes use of the access system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement access in the client's kernel and so cannot make use of the UID mapping information held on the server. Because this test is based only on the result of the access system call, there is no guarantee that a file for which this test succeeds can actually be executed.
-false  When used as part of an expression, -false always evaluates as false.
-fstype type    Returns true if a file is on a filesystem of type type. The valid filesystem types vary among different versions of Unix; an incomplete list of filesystem types that are accepted on some version of Unix or another is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K. You can use -printf with the %F directive to see the types of your filesystems.
-gid n  Returns true if a file's numeric group ID is n.
-group gname    Returns true if a file belongs to group gname (numeric group IDs are allowed).
-ilname pattern Like -lname, but the match is case insensitive. If the -L option or the -follow option is in effect, this test returns false unless the symbolic link is broken.
-iname pattern  Like -name, but the match is case insensitive. For example, the patterns 'fo</em>' and 'F??' match the file names 'Foo', 'FOO', 'foo', 'fOo', etc. In these patterns, unlike file name expansion by the shell, an initial '.' can be matched by '<em>'. That is, find -name </em>bar will match the file '.foobar'. Please note that you should always quote patterns, otherwise the shell will expand any wildcard characters in them.
-inum n Returns true if a file has inode number n. It is normally easier to use the -samefile test instead.
-ipath pattern  Behaves in the same way as -iwholename. This option is deprecated, so you should no longer use it.
-iregex pattern Like -regex, but the match is case-insensitive.
-iwholename pattern Like -wholename, but the match is case-insensitive.
-links n    Returns true if a file has n links.
-lname pattern  Returns true if a file is a symbolic link whose contents match shell pattern pattern. The metacharacters do not treat '/' or '.' specially. If the -L option or the -follow option is in effect, this test returns false unless the symbolic link is broken.
-mmin n Returns true if the file's data was last modified n minutes ago.
-mtime n    Returns true if a file's data was last modified n * 24 hours ago. See the -atime option to understand how rounding affects the interpretation of file modification times.
-name pattern   Returns true if the base of a file name (the path with the leading directories removed) matches shell pattern pattern. The metacharacters ('*', '?', and '[ ]') match a '.' at the start of the base name. To ignore a directory and the files under it, use -prune; see an example in the description of -path. Braces are not recognised as being special, despite the fact that some shells including bash imbue braces with a special meaning in shell patterns. The file name matching is performed with the use of the fnmatch library function. Don't forget to enclose the pattern in quotes to protect it from expansion by the shell.
-newer file Returns true if a file was modified more recently than the file file. If file is a symbolic link and the -H option or the -L option is in effect, the modification time of the file it points to is always used.
-newerXY reference<br />
Compares the timestamp of the current file with reference. The reference argument is normally the name of a file (and one of its timestamps is used for the comparison) but it may also be a string describing an absolute time. X and Y are placeholders for other letters, and these letters select which time belonging to how reference is used for the comparison.</p>
<p>a   The access time of the file reference
B   The birth time of the file reference
c   The inode status change time of reference
m   The modification time of the file reference
t   reference is interpreted directly as a time
Some combinations are invalid; for example, it is invalid for X to be t. Some combinations are not implemented on all systems; for example B is not supported on all systems. If an invalid or unsupported combination of XY is specified, a fatal error results. Time specifications are interpreted as for the argument to the -d option of GNU date. If you try to use the birth time of a reference file, and the birth time cannot be determined, a fatal error message results. If you specify a test which refers to the birth time of files being examined, this test will fail for any files where the birth time is unknown.
-nogroup    Returns tue if no existing group corresponds to file's numeric group ID.
-nouser Returns true if no existing user corresponds to file's numeric user ID.
-path pattern   Returns true if a file name matches shell pattern pattern. The metacharacters do not treat '/' or '.' specially; so, for example,</p>
<p>find . -path "./sr*sc"
will print an entry for a directory called './src/misc' (if one exists). To ignore a whole directory tree, use -prune rather than checking every file in the tree. For example, to skip the directory 'src/emacs' and all files and directories under it, and print the names of the other files found, do something like this:</p>
<p>find . -path ./src/emacs -prune -o -print
Note that the pattern match test applies to the whole file name, starting from one of the start points named on the command line. It would only make sense to use an absolute pathname here if the relevant start point is also an absolute path. This means that this command will never match anything:</p>
<p>find bar -path /foo/bar/myfile -print
The predicate -path is also supported by HP-UX find and will be in a forthcoming version of the POSIX standard.
-perm mode  Returns true if a file's permission bits are exactly mode (octal or symbolic). Since an exact match is required, if you want to use this form for symbolic modes, you may have to specify a rather complex mode string. For example -perm g=w will only match files which have mode 0020 (that is, ones for which group write permission is the only permission set). It is more likely that you will want to use the '/' or '-' forms, for example -perm -g=w, which matches any file with group write permission.
-perm -mode Returns true if all of the permission bits of mode are set for the file. Symbolic modes are accepted in this form, and this is usually the way in which would want to use them. You must specify 'u', 'g' or 'o' if you use a symbolic mode.
-perm /mode Returns true if any of the permission bits of mode are set for the file. Symbolic modes are accepted in this form. You must specify 'u', 'g' or 'o' if you use a symbolic mode. If no permission bits in mode are set, this test matches any file.
-perm +mode Deprecated; this is the old way of searching for files with any of the permission bits in mode. You should use -perm /mode instead. Trying to use the '+' syntax with symbolic modes will yield unexpected results.
-readable   Matches files that are readable. This takes into account access control lists and other permissions factors which the -perm test ignores. This test makes use of the access system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement access in the client's kernel and so cannot make use of the UID mapping information held on the server.
-regex pattern  Returns true if a file name matches the regular expression pattern. This is a match on the whole path, not just the file name. For example, to match a file named './fubar3', you can use the regular expression '.<em>bar.' or '.</em>b.<em>3', but not 'f.</em>r3' (because the complete path does not begin with an f). The regular expressions understood by find are by default Emacs regular expressions, but this can be changed with the -regextype option (see above).
- samefile name Returns true if a file refers to the same inode as name. When -L is in effect, this can include symbolic links.
-size [-|+]n[cwbkMG]  <br />
Returns true if a file uses n units of space on the disk. If preceded by a minus sign ("-"), matches files which use less space; if preceded by a plus sign ("+"), matches files which use more. The following suffixes can be used to abbreviate units:</p>
<p>b   for 512-byte blocks (this is the default if no suffix is used)
c   for bytes
w   for two-byte words
k   for Kilobytes (units of 1024 bytes)
M   for Megabytes (units of 1048576 bytes)
G   for Gigabytes (units of 1073741824 bytes)
The size does not count indirect blocks, but it does count blocks in sparse files that are not actually allocated. You should note that the '%k' and '%b' format specifiers of -printf handle sparse files differently. The 'b' suffix always denotes 512-byte blocks and never 1 Kilobyte blocks, which is different than the behaviour of -ls.
-true   When used in an expression, -true always returns true.
-type c 
Returns true if a file is of type c:</p>
<p>b   block (buffered) special files
c   character (unbuffered) special files
d   directories
p   named pipes (FIFOs)
f   regular files
l   symbolic links. This is never true if the -L option or the -follow option has been specified, unless the symbolic link is broken. If you want to search for symbolic links when -L is in effect, use -xtype.
s   sockets
D   doors (a Solaris file type)
-uid n  Returns true if a file's numeric user ID is n.
-used n Returns true if a file was last accessed n days after its status was last changed.
-user uname Returns true if a file is owned by user uname (numeric user IDs are allowed).
-wholename pattern  Functionally the same as -path. This alternative is less portable than -path, however; for greatest compliance across different types of systems, you should use -path instead.
-writable   Matches files that are writable. This takes into account access control lists and other permissions factors which the -perm test ignores. This test makes use of the access system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement access in the client's kernel and so cannot make use of the UID mapping information held on the server.
-xtype c    The same as -type unless the file is a symbolic link. For symbolic links: if the -H or -P option was specified, returns true if the file is a link to a file of type c; if the -L option has been given, returns true if c is 'l'. In other words, for symbolic links, -xtype checks the type of the file that -type does not check.
Actions
-delete Delete matched files; returns true if removal succeeded. If the removal failed, an error message is issued. If -delete fails, find's exit status will be nonzero (when it eventually exits). Use of -delete automatically turns on the -depth option.</p>
<p>Don't forget that the find command line is evaluated as an expression, so putting -delete first will make find try to delete everything below the starting points you specified. When testing a find command line that you later intend to use with -delete, you should explicitly specify -depth to avoid later surprises. Because -delete implies -depth, you cannot usefully use -prune and -delete together.
-exec command ; Execute command on each matched file; returns true if 0 is returned as the exit status of command. All following arguments to find are taken to be arguments to the command until a semicolon (';') is encountered. The string '{}' is replaced by the current file name being processed everywhere it occurs in the arguments to the command, not just in arguments where it is alone, as in some versions of find. Both of these constructions might need to be escaped (with a '\') or quoted to protect them from expansion by the shell. The specified command is run once for each matched file. The command is executed in the starting directory. There are unavoidable security problems surrounding use of -exec; you should use the -execdir option instead.
-exec command {} +  This variant of the -exec action runs the specified command on the selected files, but the command line is built by appending each selected file name at the end; the total number of invocations of the command will be much less than the number of matched files. The command line is built in much the same way that xargs builds its command lines. Only one instance of '{}' is allowed within the command. The command is executed in the starting directory.
-execdir command ;</p>
<p>-execdir command {} +   Like -exec, but the specified command is run from the subdirectory containing the matched file, which is not normally the directory in which you started find. This a much more secure method for invoking commands, as it avoids "race conditions" (where the behavior is determined by an unpredictable order of system operations) during resolution of the paths to the matched files. As with the -exec action, the '+' form of -execdir will build a command line to process more than one matched file, but any given invocation of command will only list files that exist in the same subdirectory. If you use this option, you must ensure that your $PATH environment variable does not reference '.'; otherwise, an attacker can run any commands they like by leaving an appropriately-named file in a directory in which you will run -execdir. The same applies to having entries in $PATH that are empty or not absolute directory names.
-fls file   Returns true; behaves like -ls, but writes to file like -fprint. The output file is always created, even if no match is found.
-fprint file    Returns true; prints the full file name into file file. If file does not exist when find is run, it is created; if it does exist, it is truncated. The file names "/dev/stdout" and "/dev/stderr" are handled specially; they refer to the standard output and standard error output, respectively. The output file is always created, even if the predicate is never matched.
-fprint0 file   Returns true; like -print0 but writes to file like -fprint. The output file is always created, even if no match is found.
-fprintf file format    Returns true; like -printf, but writ</p>
<p>ionalisation message catalogues.
PATH    Affects the directories that are searched to find the executables invoked by -exec, -execdir, -ok and -okdir.
POSIXLY_CORRECT Determines the block size used by -ls and -fls. If POSIXLY_CORRECT is set, blocks are units of 512 bytes. Otherwise, they are units of 1024 bytes.</p>
<p>Setting this variable also turns off warning messages (that is, implies -nowarn) by default, because POSIX requires that apart from the output for -ok, all messages printed on stderr are diagnostics and must result in a non-zero exit status.</p>
<p>When POSIXLY_CORRECT is not set, -perm +zzz is treated just like -perm /zzz if +zzz is not a valid symbolic mode. When POSIXLY_CORRECT is set, such constructs are treated as an error.</p>
<p>When POSIXLY_CORRECT is set, the response to the prompt made by the -ok action is interpreted according to the system's message catalogue, as opposed to according to find's own message translations.
TZ  Affects the time zone used for some of the time-related format directives of -printf and -fprintf.
Examples
find
When using linux, running the find command without any options will locate and print a list of every file in and beneath the current directory. This includes all files in all subdirectories of the current directory.</p>
<p>find .
Same as the above command. The "." explicitly tells find that you want the search to begin in the current directory.</p>
<p>find . /home/jeff /home/stacy
Locate and print all files and directories in and beneath three different starting directories: the current directory, /home/jeff, and /home/stacy.</p>
<p>find /usr/bin /usr/lib -name '<em>zip</em>'
Locate and print all files and directories in and beneath either of the directories /usr/bin and /usr/lib which contains the text "zip" anywhere in the file or directory name.</p>
<p>find /home/jeff/fruit | grep 'apple'
This command tells find to locate and print a complete list of all files in and beneath the directory /home/jeff/fruit, and to pipe this listing to grep, which filters out any file name which does not contain the text "apple".</p>
<p>find . -name 'apple'
Locate and print a list of any file in or below the current directory whose name is exactly "apple", all lower case letters.</p>
<p>find . -iname 'apple'
Locate and print a list of any file in or below the current directory whose name is "apple", but match the letters case-insensitively. Therefore, files or directories named "Apple", "ApplE", and "ApPLe" will all be listed by this command.</p>
<p>find . -name 'apple' -type f
Locate and print a list of files in or below the current directory whose name is "apple"; do not display directories, sockets, or other non-regular file types.</p>
<p>find . -name 'apple' -type d
Locate a print a list of directories in or below the current directory whose name is "apple"; do not display regular files, or file types other than directory entries.</p>
<p>find . -group dev
Locate and print a list of any file in or below the current directory whose owning group is the dev group.</p>
<p>find . -L
Locate and print a list of any file in or below the current directory, and follow symbolic links. In other words, display information about the file a symbolic link links to, rather than information about the symlink itself.</p>
<p>find . -atime +1
Locate and print a list of any file in or below the current directory that was last accessed more than 1 day ago.</p>
<p>find . -atime -1
Locate and print a list of any file in or below the current directory that was last accessed less than 1 day ago.</p>
<p>find . -amin +5
Locate and print a list of any file in or below the current directory that was modified more than 5 minutes ago.</p>
<p>find . -amin -5
Locate and print a list of any file in or below the current directory that was modified fewer than 5 minutes ago.</p>
<p>find . -perm 754
Locate and print a list of any file in or below the current directory whose octal permission bits are 755 (user can read, write, and execute; owning group members can read and execute; others can read only). For more information about permission bits, see chmod.</p>
<p>find . -perm u=rwx,g=rx,o=r
Same as the above command, but uses a symbolic representation of the permission bits. Note that the symbolic notation uses a comma separator and contains no spaces.</p>
<p>find . -size +1M -type f
Locate and print a list of any regular file in or below the current directory whose size is greater than 1 megabyte.</p>
<p>find . -size -5G -type f
Locate and print a list of any regular file in or below the current directory whose size is less than 5 gigabytes.</p>
<p>find . -user jeff
Locate and print a list of any file or directory in or below the current directory owned by the user jeff.</p>
<p>find . -size +1G -exec mv '{}' ~/bigfiles \;
Locate any files in or below the current directory whose size is greater than 1 gigabyte, and execute the mv command on them, moving them into the directory bigfiles in your home directory. The {} indicates where in the command the name of the matched file should be placed; it must be enclosed in quotes to protect it from being misinterpreted by the shell. Similarly, the semicolon which ends the command must be escaped with a backslash ("\;").</p>
<p>find . -size +1G -print0 | xargs -0 -I '{}' mv '{}' ~/bigfiles
Locate any files in or below the current directory whose size is greater than 1 gigabyte, then pipe that list to the xargs command, which uses the mv command to move each one of those files into the directory bigfiles in your home directory. This is similar to the above command, but better for several reasons. First, it uses the -print0 option to tell find to create its list separating each file name with a null character rather than a newline; this makes the list difficult for a human to read, but has the advantage of making it easier for another program to parse. You should always use -print0 when piping output to xargs.</p>
<p>Using xargs to execute commands on every file found is generally better than using find's -exec option because of the more efficient way xargs threads each command that it spawns.</p>
<p>The -0 argument to xargs tells it to expect the null character as the file name separator (which we specified with find's -print0 option).</p>
<p>The -I '{}' option tells xargs to replace "{}" with the name of each file it finds. We then form our command using {} where we want the file name to appear. We enclose it in single quotes to protect it from the shell.</p>
<p>xargs does not expect a semicolon at the end of the command, unlike find -exec, so it is not included in this command.</p>
<p>find . -size +1G -ok mv '{}' ~/bigfiles \;
Using -ok is the same as using -exec, but you will be asked for confirmation before each command is executed.</p>
<p>find . -name '<em>.jpg' -o -name '</em>.gif'
Locate any files in or below the current directory whose suffix is ".jpg" or ".gif". The -o option functions as a boolean OR operator; if either of the conditions are true, the file will be included in the list.</p>
<p>find . -maxdepth 2 -name '*.jpg'
Locate any files in or below the current directory whose suffix is ".jpg", but limit subdirectory traversal to 2 levels beneath the current directory. Any subdirectories 3 or more levels deep will not be searched.</p>
<p>find . ! -name '*.jpg'
Locate any files in or below the current directory whose suffix is not ".jpg". The exclamation mark ("!") functions as a boolean NOT operator; it lists only files for which the condition is false.</p>
<p>find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
Find files named core in or below the directory /tmp and delete them. The -name test comes before the -type test to avoid having to call stat on every file.</p>
<p>find $HOME -mtime 0
Search for files in your home directory which have been modified in the last twenty-four hours. This command works this way because the time since each file was last modified is divided by 24 hours and any remainder is discarded. That means that to match -mtime 0, a file will have to have a modification in the past that is less than 24 hours ago.</p>
<p>find /sbin /usr/sbin -executable ! -readable
Search for files in your superuser binary directories, /sbin and /usr/sbin, which are executable but not readable.</p>
<h2 id="suppressing-error-messages-when-using-find">Suppressing Error Messages When Using find</h2>
<p>One last tip for using find: you will receive an error message if find encounters a file or directory you don't have access to view. The error message will look like this:</p>
<p>find: `./tmp/sysfile-PKdhtXMmr18n': Permission denied
You might not want these messages in your output; they can make it difficult to parse your actual find results.</p>
<p>For these examples, we'll assume you're using bash as your shell, which is the default under linux. Let's say your command is this simple one:</p>
<p>find .
If the results of this command are giving you "Permission denied" errors, the simplest way to filter them out is to send them all to /dev/null, which is the device on linux which points to nowhere. Your command would look like this:</p>
<p>find . 2&gt;/dev/null
Here, 2&gt; is a special operator in bash which means "redirect standard error". This will effectively hide all error messages from find's output.</p>
<p>You might not want to hide every error message, though. What if there's another error of some kind? You don't want to suppress those messages too. In that case, you can use this command instead:</p>
<p>find . 2&gt;&amp;1 | grep -v 'Permission denied'
Here, 2&gt; tells bash to redirect standard error, and &amp;1 tells it to use standard output as the destination. This redirects all error messages issued by find to standard output; this will look the same on your terminal screen, but by merging them with standard output, we have made them filterable by grep. So we then pipe the output of find to grep, which matches the inverse (-v) of our string, 'Permission denied'. The result is that it displays any line which does not contain that string. This allows you to view your results without any pesky "Permission denied" error messages.es to file like -fprint. The output file is always created, even if the predicate is never matched.
-ls Returns true; lists current file in ls -dils format (see ls for details) on standard output. The block counts are of 1K blocks, unless the environment variable POSIXLY_CORRECT is set, in which case 512-byte blocks are used.
-ok command ;   Like -exec, but asks the user first. If the user agrees, find runs the command. Otherwise, it returns false. If the command is run, its standard input is redirected from /dev/null.</p>
<p>The response to the prompt is matched against a pair of regular expressions to determine if it is an affirmative or negative response. This regular expression is obtained from the system if the 'POSIXLY_CORRECT' environment variable is set, or otherwise from find's message translations. If the system has no suitable definition, find's own definition will be used. In either case, the interpretation of the regular expression itself will be affected by the environment variables 'LC_CTYPE' (character classes) and 'LC_COLLATE' (character ranges and equivalence classes).
-okdir command ;    Like -execdir but asks the user first in the same way as for -ok. If the user does not agree, returns false. If the command is run, its standard input is redirected from /dev/null.
-print  Returns true; prints the full file name on the standard output, followed by a newline. If you are piping the output of find into another program and there is the faintest possibility that the files which you are searching for might contain a newline, then you should consider using the -print0 option instead of -print.
-print0 Returns true; prints the full file name on the standard output, followed by a null character (instead of the newline character that -print uses). This allows file names that contain newlines or other types of white space to be correctly interpreted by programs that process the find output. This option corresponds to the -0 option of xargs.
-printf format<br />
Returns true; prints format on the standard output, interpreting '\' escapes and '%' directives. Field widths and precisions can be specified as with the 'printf' C function. Please note that many of the fields are printed as %s rather than %d, and this may mean that flags don't work as you might expect. This also means that the '-' flag does work (it forces fields to be left-aligned). Unlike -print, -printf does not add a newline at the end of the string. The escapes and directives are:</p>
<p>\a  Alarm bell.
\b  Backspace.
\c  Stop printing using format immediately and flush the remaining output.
\f  Form feed.
\n  Newline.
\r  Carriage return.
\t  Horizontal tab.
\v  Vertical tab.
\0  The ASCII NUL character.
\  A literal backslash ('\').
\NNN    The character whose ASCII code is NNN (where NNN is an octal value).
A '\' character followed by any other character is treated as an ordinary character, so they both are printed.</p>
<p>%%  A literal percent sign.
%a  The file's last access time in the format returned by the C ctime function.
%Ak 
The file's last access time in the format specified by k, which is either '@' or a directive of the C 'strftime' function. The possible values for k are listed below; some of them might not be available on all systems, due to differences in strftime between systems.</p>
<p>Values for k can be one of the following:</p>
<p>@   seconds since Jan. 1, 1970, 00:00 GMT, with fractional part.
Time fields:</p>
<p>H   hour (00..23)
I   hour (01..12)
k   hour ( 0..23)
l   hour ( 1..12)
M   minute (00..59)
p   locale's AM or PM
r   time, 12-hour (hh:mm:ss [AP]M)
S   Second (00.00 .. 61.00). There is a fractional part.
T   time, 24-hour (hh:mm:ss)
+   Date and time, separated by '+', for example '2004-04-28+22:22:05.0'. This is a GNU extension. The time is given in the current timezone (which may be affected by setting the TZ environment variable). The seconds field includes a fractional part.
X   locale's time representation (H:M:S)
Z   time zone (e.g., EDT), or nothing if no time zone is determinable
Date fields:</p>
<p>a   locale's abbreviated weekday name (Sun..Sat)
A   locale's full weekday name, variable length (Sunday..Saturday)
b   locale's abbreviated month name (Jan..Dec)
B   locale's full month name, variable length (January..December)
c   locale's date and time (Sat Nov 04 12:02:33 EST 1989). The format is the same as for ctime and so to preserve compatibility with that format, there is no fractional part in the seconds field.
d   day of month (01..31)
D   date (mm/dd/yy)
h   same as b
j   day of year (001..366)
m   month (01..12)
U   week number of year with Sunday as first day of week (00..53)
w   day of week (0..6)
W   week number of year with Monday as first day of week (00..53)
x   locale's date representation (mm/dd/yy)
y   last two digits of year (00..99)
Y   year (1970..)
%b  The amount of disk space used for this file in 512-byte blocks. Since disk space is allocated in multiples of the filesystem block size this is usually greater than %s/512, but it can also be smaller if the file is a sparse file.
%c  File's last status change time in the format returned by the C 'ctime' function.
%Ck File's last status change time in the format specified by k, which is the same as for %A.
%d  File's depth in the directory tree; 0 means the file is a command line argument.
%D  The device number on which the file exists (the st_dev field of struct stat), in decimal.
%f  File's name with any leading directories removed (only the last element).
%F  Type of the filesystem the file is on; this value can be used for -fstype.
%g  File's group name, or numeric group ID if the group has no name.
%G  File's numeric group ID.
%h  Leading directories of file's name (all but the last element). If the file name contains no slashes (since it is in the current directory) the %h specifier expands to ".".
%H  Command line argument under which file was found.
%i  File's inode number (in decimal).
%k  The amount of disk space used for this file in 1K blocks. Since disk space is allocated in multiples of the filesystem block size this is usually greater than %s/1024, but it can also be smaller if the file is a sparse file.
%l  Object of symbolic link (empty string if file is not a symbolic link).
%m  File's permission bits (in octal). This option uses the 'traditional' numbers which most Unix implementations use, but if your particular implementation uses an unusual ordering of octal permissions bits, you will see a difference between the actual value of the file's mode and the output of %m. Normally you will want to have a leading zero on this number, and to do this, you should use the # flag (as in, for example, '%#m').
%M  File's permissions (in symbolic form, as for ls).
%n  Number of hard links to file.
%p  File's name.
%P  File's name with the name of the command line argument under which it was found removed.
%s  File's size in bytes.
%S  File's sparseness. This is calculated as (BLOCKSIZE*st_blocks / st_size). The exact value you will get for an ordinary file of a certain length is system-dependent. However, normally sparse files will have values less than 1.0, and files which use indirect blocks may have a value that is greater than 1.0. The value used for BLOCKSIZE is system-dependent, but is usually 512 bytes. If the file size is zero, the value printed is undefined. On systems which lack support for st_blocks, a file's sparseness is assumed to be 1.0.
%t  File's last modification time in the format returned by the C 'ctime' function.
%Tk File's last modification time in the format specified by k, which is the same as for %A.
%u  File's user name, or numeric user ID if the user has no name.
%U  File's numeric user ID.
%y  File's type (like in ls -l). U=unknown type (although this shouldn't happen)
%Y  File's type (like %y), plus follow symlinks: L=loop, N=nonexistent
A '%' character followed by any other character is discarded, but the other character is printed (but don't rely on this, as further format characters may be introduced). A '%' at the end of the format argument causes undefined behaviour since there is no following character. In some locales, it may hide your door keys, while in others it may remove the final page from the novel you are reading.</p>
<p>The %m and %d directives support the # , 0 and + flags, but the other directives do not, even if they print numbers. Numeric directives that do not support these flags include G, U, b, D, k and n. The '-' format flag is supported and changes the alignment of a field from right-justified (which is the default) to left-justified.</p>
<p>-prune  True; if the file is a directory, do not descend into it. If -depth is given, false; no effect. Because -delete implies -depth, you cannot usefully use -prune and -delete together.
-quit   Exit immediately. No child processes will be left running, but no more paths specified on the command line will be processed. For example, find /tmp/foo /tmp/bar -print -quit will print only /tmp/foo. Any command lines which have been built up with -execdir ... {} + will be invoked before find exits. The exit status may or may not be zero, depending on whether an error has already occurred.
Handling Unusual File Names
Many of the actions of find result in the printing of data that is under the control of other users. This includes file names, sizes, modification times and so forth. File names are a potential problem since they can contain any character except '\0' and '/'. Unusual characters in file names can do unexpected and often undesirable things to your terminal (for example, changing the settings of your function keys on some terminals). Unusual characters are handled differently by various actions, as described below:</p>
<p>-print0, -fprint0   Always print the exact file name, unchanged, even if the output is going to a terminal.
-ls, -fls   Unusual characters are always escaped. White space, backslash, and double quote characters are printed using C-style escaping (for example '\f', '\"'). Other unusual characters are printed using an octal escape. Other printable characters (for -ls and -fls these are the characters between octal 041 and 0176) are printed as is.
-printf, -fprintf   If the output is not going to a terminal, it is printed as is. Otherwise, the result depends on which directive is in use. The directives %D, %F, %g, %G, %H, %Y, and %y expand to values that are not under control of files' owners, and so are printed as is. The directives %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u and %U have values that are under the control of files' owners but which cannot be used to send arbitrary data to the terminal, and so these are printed as is. The directives %f, %h, %l, %p and %P are quoted. This quoting is performed in the same way as for GNU ls. This is not the same quoting mechanism as the one used for -ls and -fls. If you can decide what format to use for the output of find then it is normally better to use '\0' as a terminator than to use newline, as file names can contain white space and newline characters. The setting of the 'LC_CTYPE' environment variable is used to determine which characters need to be quoted.
-print, -fprint Quoting is handled in the same way as for -printf and -fprintf. If you are using find in a script or in a situation where the matched files might have arbitrary names, you should consider using -print0 instead of -print.
The -ok and -okdir actions print the current file name as is.</p>
<p>Operators
The following find operators are listed in order of increasing precedence:</p>
<p>( expr )    Force precedence. Since parentheses are special to the shell, you will normally need to quote them. For instance, you will probably need to specify '(...)' instead of '(...)'.
! expr  Returns true if expr is false. This character will also usually need protection from interpretation by the shell.
-not expr   Same as ! expr, but not POSIX compliant.
expr1 expr2 Two expressions in a row are taken to be joined with an implied "and"; in other words, expr2 is not evaluated if expr1 is false.
expr1 -a expr2  Same as expr1 expr2.
expr1 -and expr2    Same as expr1 expr2, but not POSIX compliant.
expr1 -o expr2  Boolean OR; in other words, expr2 is not evaluated if expr1 is true.
expr1 -or expr2 Same as expr1 -o expr2, but not POSIX compliant.
expr1 , expr2   Separating two expressions with a comma treats them as a list: both expr1 and expr2 are always evaluated. The value of expr1 is discarded in the return value; the value of the list is the value of expr2. The comma operator can be useful for searching for different types of thing, but traversing the filesystem hierarchy only once. The -fprintf action can be used to list the various matched items into different output files.
Environment Variables
LANG    Provides a default value for the internationalization variables that are unset or null.
LC_ALL  If set to a non-empty string value, this variable's value overrides the values of all the other internationalization variables.
LC_COLLATE  The POSIX standard specifies that this variable affect the pattern matching to be used for the -name option. GNU find uses the fnmatch library function, and so support for 'LC_COLLATE' depends on the system library. This variable also affects the interpretation of the response to -ok; while the 'LC_MESSAGES' variable selects the actual pattern used to interpret the response to -ok, the interpretation of any bracket expressions in the pattern will be affected by 'LC_COLLATE'.
LC_CTYPE    This variable affects the treatment of character classes used in regular expressions and also with the -name test, if the system's fnmatch library function supports this. This variable also affects the interpretation of any character classes in the regular expressions used to interpret the response to the prompt issued by -ok. The 'LC_CTYPE' environment variable will also affect which characters are considered to be unprintable when file names are printed.
LC_MESSAGES Determines the locale to be used for internationalised messages. If the 'POSIXLY_CORRECT' environment variable is set, this also determines the interpretation of the response to the prompt made by the -ok action.
NLSPATH Determines the location of the internationalisation message catalogues.
PATH    Affects the directories that are searched to find the executables invoked by -exec, -execdir, -ok and -okdir.
POSIXLY_CORRECT Determines the block size used by -ls and -fls. If POSIXLY_CORRECT is set, blocks are units of 512 bytes. Otherwise, they are units of 1024 bytes.</p>
<p>Setting this variable also turns off warning messages (that is, implies -nowarn) by default, because POSIX requires that apart from the output for -ok, all messages printed on stderr are diagnostics and must result in a non-zero exit status.</p>
<p>When POSIXLY_CORRECT is not set, -perm +zzz is treated just like -perm /zzz if +zzz is not a valid symbolic mode. When POSIXLY_CORRECT is set, such constructs are treated as an error.</p>
<p>When POSIXLY_CORRECT is set, the response to the prompt made by the -ok action is interpreted according to the system's message catalogue, as opposed to according to find's own message translations.
TZ  Affects the time zone used for some of the time-related format directives of -printf and -fprintf.
Examples
find
When using linux, running the find command without any options will locate and print a list of every file in and beneath the current directory. This includes all files in all subdirectories of the current directory.</p>
<p>find .
Same as the above command. The "." explicitly tells find that you want the search to begin in the current directory.</p>
<p>find . /home/jeff /home/stacy
Locate and print all files and directories in and beneath three different starting directories: the current directory, /home/jeff, and /home/stacy.</p>
<p>find /usr/bin /usr/lib -name '<em>zip</em>'
Locate and print all files and directories in and beneath either of the directories /usr/bin and /usr/lib which contains the text "zip" anywhere in the file or directory name.</p>
<p>find /home/jeff/fruit | grep 'apple'
This command tells find to locate and print a complete list of all files in and beneath the directory /home/jeff/fruit, and to pipe this listing to grep, which filters out any file name which does not contain the text "apple".</p>
<p>find . -name 'apple'
Locate and print a list of any file in or below the current directory whose name is exactly "apple", all lower case letters.</p>
<p>find . -iname 'apple'
Locate and print a list of any file in or below the current directory whose name is "apple", but match the letters case-insensitively. Therefore, files or directories named "Apple", "ApplE", and "ApPLe" will all be listed by this command.</p>
<p>find . -name 'apple' -type f
Locate and print a list of files in or below the current directory whose name is "apple"; do not display directories, sockets, or other non-regular file types.</p>
<p>find . -name 'apple' -type d
Locate a print a list of directories in or below the current directory whose name is "apple"; do not display regular files, or file types other than directory entries.</p>
<p>find . -group dev
Locate and print a list of any file in or below the current directory whose owning group is the dev group.</p>
<p>find . -L
Locate and print a list of any file in or below the current directory, and follow symbolic links. In other words, display information about the file a symbolic link links to, rather than information about the symlink itself.</p>
<p>find . -atime +1
Locate and print a list of any file in or below the current directory that was last accessed more than 1 day ago.</p>
<p>find . -atime -1
Locate and print a list of any file in or below the current directory that was last accessed less than 1 day ago.</p>
<p>find . -amin +5
Locate and print a list of any file in or below the current directory that was modified more than 5 minutes ago.</p>
<p>find . -amin -5
Locate and print a list of any file in or below the current directory that was modified fewer than 5 minutes ago.</p>
<p>find . -perm 754
Locate and print a list of any file in or below the current directory whose octal permission bits are 755 (user can read, write, and execute; owning group members can read and execute; others can read only). For more information about permission bits, see chmod.</p>
<p>find . -perm u=rwx,g=rx,o=r
Same as the above command, but uses a symbolic representation of the permission bits. Note that the symbolic notation uses a comma separator and contains no spaces.</p>
<p>find . -size +1M -type f
Locate and print a list of any regular file in or below the current directory whose size is greater than 1 megabyte.</p>
<p>find . -size -5G -type f
Locate and print a list of any regular file in or below the current directory whose size is less than 5 gigabytes.</p>
<p>find . -user jeff
Locate and print a list of any file or directory in or below the current directory owned by the user jeff.</p>
<p>find . -size +1G -exec mv '{}' ~/bigfiles \;
Locate any files in or below the current directory whose size is greater than 1 gigabyte, and execute the mv command on them, moving them into the directory bigfiles in your home directory. The {} indicates where in the command the name of the matched file should be placed; it must be enclosed in quotes to protect it from being misinterpreted by the shell. Similarly, the semicolon which ends the command must be escaped with a backslash ("\;").</p>
<p>find . -size +1G -print0 | xargs -0 -I '{}' mv '{}' ~/bigfiles
Locate any files in or below the current directory whose size is greater than 1 gigabyte, then pipe that list to the xargs command, which uses the mv command to move each one of those files into the directory bigfiles in your home directory. This is similar to the above command, but better for several reasons. First, it uses the -print0 option to tell find to create its list separating each file name with a null character rather than a newline; this makes the list difficult for a human to read, but has the advantage of making it easier for another program to parse. You should always use -print0 when piping output to xargs.</p>
<p>Using xargs to execute commands on every file found is generally better than using find's -exec option because of the more efficient way xargs threads each command that it spawns.</p>
<p>The -0 argument to xargs tells it to expect the null character as the file name separator (which we specified with find's -print0 option).</p>
<p>The -I '{}' option tells xargs to replace "{}" with the name of each file it finds. We then form our command using {} where we want the file name to appear. We enclose it in single quotes to protect it from the shell.</p>
<p>xargs does not expect a semicolon at the end of the command, unlike find -exec, so it is not included in this command.</p>
<p>find . -size +1G -ok mv '{}' ~/bigfiles \;
Using -ok is the same as using -exec, but you will be asked for confirmation before each command is executed.</p>
<p>find . -name '<em>.jpg' -o -name '</em>.gif'
Locate any files in or below the current directory whose suffix is ".jpg" or ".gif". The -o option functions as a boolean OR operator; if either of the conditions are true, the file will be included in the list.</p>
<p>find . -maxdepth 2 -name '*.jpg'
Locate any files in or below the current directory whose suffix is ".jpg", but limit subdirectory traversal to 2 levels beneath the current directory. Any subdirectories 3 or more levels deep will not be searched.</p>
<p>find . ! -name '*.jpg'
Locate any files in or below the current directory whose suffix is not ".jpg". The exclamation mark ("!") functions as a boolean NOT operator; it lists only files for which the condition is false.</p>
<p>find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
Find files named core in or below the directory /tmp and delete them. The -name test comes before the -type test to avoid having to call stat on every file.</p>
<p>find $HOME -mtime 0
Search for files in your home directory which have been modified in the last twenty-four hours. This command works this way because the time since each file was last modified is divided by 24 hours and any remainder is discarded. That means that to match -mtime 0, a file will have to have a modification in the past that is less than 24 hours ago.</p>
<p>find /sbin /usr/sbin -executable ! -readable
Search for files in your superuser binary directories, /sbin and /usr/sbin, which are executable but not readable.</p>
<h2 id="suppressing-error-messages-when-using-find_1">Suppressing Error Messages When Using find</h2>
<p>One last tip for using find: you will receive an error message if find encounters a file or directory you don't have access to view. The error message will look like this:</p>
<p>find: `./tmp/sysfile-PKdhtXMmr18n': Permission denied
You might not want these messages in your output; they can make it difficult to parse your actual find results.</p>
<p>For these examples, we'll assume you're using bash as your shell, which is the default under linux. Let's say your command is this simple one:</p>
<p>find .
If the results of this command are giving you "Permission denied" errors, the simplest way to filter them out is to send them all to /dev/null, which is the device on linux which points to nowhere. Your command would look like this:</p>
<p>find . 2&gt;/dev/null
Here, 2&gt; is a special operator in bash which means "redirect standard error". This will effectively hide all error messages from find's output.</p>
<p>You might not want to hide every error message, though. What if there's another error of some kind? You don't want to suppress those messages too. In that case, you can use this command instead:</p>
<p>find . 2&gt;&amp;1 | grep -v 'Permission denied'
Here, 2&gt; tells bash to redirect standard error, and &amp;1 tells it to use standard output as the destination. This redirects all error messages issued by find to standard output; this will look the same on your terminal screen, but by merging them with standard output, we have made them filterable by grep. So we then pipe the output of find to grep, which matches the inverse (-v) of our string, 'Permission denied'. The result is that it displays any line which does not contain that string. This allows you to view your results without any pesky "Permission denied" error messages.</p>
<p>例子：</p>
<ol>
<li>
<p>列出结尾不是 .rpm 的文件，并删除</p>
<p>find -type f ( ! -iname "*.rpm" ) -print -exec rm {} \;^C</p>
</li>
</ol>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../command-runuser/" class="btn btn-neutral float-right" title="Command: RUNUSER">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../" class="btn btn-neutral" title="Linux命令参考"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>
<!-- 
  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
-->
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../command-runuser/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>

</body>
</html>
